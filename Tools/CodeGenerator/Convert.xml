<?xml version="1.0" encoding="utf-8"?>
<code transformer="Convert.xslt">

	<using namespace="System"/>
	<using namespace="System.Data.SqlTypes"/>
	<using namespace="System.Globalization"/>
	<using namespace="System.IO"/>
	<using namespace="System.Xml"/>
	<br/>
	<using namespace="BLToolkit.Properties"/>

	<type name="SByte"  clscompliant="false"/>
	<type name="UInt16" clscompliant="false"/>
	<type name="UInt32" clscompliant="false"/>
	<type name="UInt64" clscompliant="false"/>

	<type name="DateTimeOffset" condition="FW3"/>

	<template name="Integer Types">
		<type name="SByte"   />
		<type name="Int16"   />
		<type name="Int32"   />
		<type name="Int64"   />
		<br/>
		<type name="Byte"    />
		<type name="UInt16"  />
		<type name="UInt32"  />
		<type name="UInt64"  />
	</template>

	<template name="Numeric Types">
		<include template="Integer Types"/>
		<br/>
		<type name="Single"  />
		<type name="Double"  />
		<br/>
		<type name="Boolean" />
		<type name="Decimal" />
	</template>

	<template name="SqlTypes">
		<type name="SqlString"/>
		<br/>
		<type name="SqlByte"/>
		<type name="SqlInt16"/>
		<type name="SqlInt32"/>
		<type name="SqlInt64"/>
		<br/>
		<type name="SqlSingle"/>
		<type name="SqlDouble"/>
		<type name="SqlDecimal"/>
		<type name="SqlMoney"/>
		<br/>
		<type name="SqlBoolean"/>
	</template>

	<region name="Scalar Types">
		<converter type="String">
			<group name="Scalar Types.">
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="TimeSpan"/>
				<from type="DateTime"/>
				<from type="DateTimeOffset"/>
				<from type="Guid"/>
				<default              >return p.ToString();</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="TimeSpan"/>
				<from type="DateTime"/>
				<from type="DateTimeOffset"/>
				<from type="Guid"/>
				<default              >return p.ToString();</default>
			</group>
			<group name="SqlTypes">
				<include template ="SqlTypes"/>
				<from type="SqlGuid"/>
				<from type="SqlChars" >return p.IsNull?  null: p.ToSqlString().Value;</from>
				<from type="SqlXml"   >return p.IsNull?  null: p.Value;</from>
				<default              >return p.ToString();</default>
			</group>
			<group name="Other Types">
				<from type="Type"       >return p == null? null: p.FullName;</from>
				<from type="XmlDocument">return p == null? null: p.InnerXml;</from>
				<from type="Byte[]"     >return p == null? null: System.Text.Encoding.UTF8.GetString(p);</from>
			</group>
			<default nullvalue="Common.Configuration.NullableValues.String" nothrow="true">
			if (p is IConvertible) return ((IConvertible)p).ToString(null);
			if (p is IFormattable) return ((IFormattable)p).ToString(null, null);

			return p.ToString();</default>
		</converter>
		<br/>
		<converter type="SByte"    nullable="false">
			<group name="Scalar Types.">
				<from type="String"   >return p == null? (SByte)0: SByte.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Boolean"  >return       (SByte)(p? 1: 0);</from>
				<from type="Char"/>
				<default              >return      checked((SByte)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="SByte"    >return p.HasValue?                 p.Value: (SByte)0;</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return (p.HasValue &amp;&amp; p.Value)?   (SByte)1: (SByte)0;</from>
				<default              >return p.HasValue? checked((SByte)p.Value): (SByte)0;</default>
			</group>
			<group name="SqlTypes">
				<include template ="SqlTypes"/>
				<default              >return p.IsNull? (SByte)0:        ToSByte(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? (SByte)0: checked((SByte)p[0]);</from>
			</group>
			<default nullvalue="Common.Configuration.NullableValues.SByte">
			if (p is IConvertible) return ((IConvertible)p).ToSByte(null);
			</default>
		</converter>
		<converter type="Int16"    nullable="false">
			<group name="Scalar Types.">
				<from type="String"   >return p == null? (Int16)0: Int16.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Boolean"  >return       (Int16)(p? 1: 0);</from>
				<from type="Char"/>
				<default              >return      checked((Int16)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="Int16"    >return p.HasValue?                 p.Value: (Int16)0;</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return (p.HasValue &amp;&amp; p.Value)?   (Int16)1: (Int16)0;</from>
				<default              >return p.HasValue? checked((Int16)p.Value): (Int16)0;</default>
			</group>
			<group name="SqlTypes">
				<from type="SqlInt16" >return p.IsNull? (Int16)0:                p.Value; </from>
				<include template ="SqlTypes"/>
				<default              >return p.IsNull? (Int16)0:        ToInt16(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? (Int16)0: BitConverter.ToInt16(p, 0);</from>
			</group>
			<default nullvalue="Common.Configuration.NullableValues.Int16">
			if (p is IConvertible) return ((IConvertible)p).ToInt16(null);
			</default>
		</converter>
		<converter type="Int32"    nullable="false">
			<group name="Scalar Types.">
				<from type="String"   >return p == null? 0: Int32.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Boolean"  >return p? 1: 0;</from>
				<from type="Char"/>
				<default              >return checked((Int32)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="Int32"    >return p.HasValue?                 p.Value: 0;</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return (p.HasValue &amp;&amp; p.Value)?   1: 0;</from>
				<default              >return p.HasValue? checked((Int32)p.Value): 0;</default>
			</group>
			<group name="SqlTypes">
				<from type="SqlInt32" >return p.IsNull? 0:         p.Value; </from>
				<include template ="SqlTypes"/>
				<default              >return p.IsNull? 0: ToInt32(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? 0: BitConverter.ToInt32(p, 0);</from>
			</group>
			<default nullvalue="Common.Configuration.NullableValues.Int32">
			if (p is IConvertible) return ((IConvertible)p).ToInt32(null);
			</default>
		</converter>
		<converter type="Int64"    nullable="false">
			<group name="Scalar Types.">
				<from type="String"   >return p == null? 0: Int64.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return p? 1: 0;</from>
				<from type="DateTime" >return (p - DateTime.MinValue).Ticks;</from>
				<from type="DateTimeOffset" >return (p - DateTime.MinValue).Ticks;</from>
				<from type="TimeSpan" >return p.Ticks;</from>
				<default              >return checked((Int64)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="Int64"    >return p.HasValue?                 p.Value: 0;</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return (p.HasValue &amp;&amp; p.Value)? 1: 0;</from>
				<from type="DateTime" >return p.HasValue? (p.Value - DateTime.MinValue).Ticks: 0;</from>
				<from type="DateTimeOffset" >return p.HasValue? (p.Value - DateTime.MinValue).Ticks: 0;</from>
				<from type="TimeSpan" >return p.HasValue? p.Value.Ticks: 0;</from>
				<default              >return p.HasValue? checked((Int64)p.Value): 0;</default>
			</group>
			<group name="SqlTypes">
				<from type="SqlInt64" >return p.IsNull? 0:         p.Value; </from>
				<include template ="SqlTypes"/>
				<from type="SqlDateTime"/>
				<default              >return p.IsNull? 0: ToInt64(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? 0: BitConverter.ToInt64(p, 0);</from>
			</group>
			<default nullvalue="Common.Configuration.NullableValues.Int64">
			if (p is IConvertible) return ((IConvertible)p).ToInt64(null);
			</default>
		</converter>
		<br/>
		<converter type="Byte"    nullable="false">
			<group name="Scalar Types.">
				<from type="String"   >return p == null? (Byte)0: Byte.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Boolean"  >return       (Byte)(p? 1: 0);</from>
				<from type="Char"/>
				<default              >return      checked((Byte)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="Byte"     >return p.HasValue?               p.Value:  (Byte)0;</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return (p.HasValue &amp;&amp; p.Value)?   (Byte)1: (Byte)0;</from>
				<default              >return p.HasValue? checked((Byte)p.Value): (Byte)0;</default>
			</group>
			<group name="SqlTypes">
				<from type="SqlByte"  >return p.IsNull? (Byte)0:               p.Value; </from>
				<include template ="SqlTypes"/>
				<default              >return p.IsNull? (Byte)0:        ToByte(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? (Byte)0: p[0];</from>
			</group>
			<default nullvalue="Common.Configuration.NullableValues.Byte">
			if (p is IConvertible) return ((IConvertible)p).ToByte(null);
			</default>
		</converter>
		<converter type="UInt16"    nullable="false">
			<group name="Scalar Types.">
				<from type="String"   >return p == null? (UInt16)0: UInt16.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Boolean"  >return       (UInt16)(p? 1: 0);</from>
				<from type="Char"/>
				<default              >return      checked((UInt16)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="UInt16"    >return p.HasValue?                 p.Value:  (UInt16)0;</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return (p.HasValue &amp;&amp; p.Value)?   (UInt16)1: (UInt16)0;</from>
				<default              >return p.HasValue? checked((UInt16)p.Value): (UInt16)0;</default>
			</group>
			<group name="SqlTypes">
				<include template ="SqlTypes"/>
				<default              >return p.IsNull? (UInt16)0:        ToUInt16(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? (UInt16)0: BitConverter.ToUInt16(p, 0);</from>
			</group>
			<default nullvalue="Common.Configuration.NullableValues.UInt16">
			if (p is IConvertible) return ((IConvertible)p).ToUInt16(null);
			</default>
		</converter>
		<converter type="UInt32"    nullable="false">
			<group name="Scalar Types.">
				<from type="String"   >return p == null? 0: UInt32.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Boolean"  >return       (UInt32)(p? 1: 0);</from>
				<from type="Char"/>
				<default              >return      checked((UInt32)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="UInt32"    >return p.HasValue?                 p.Value:  0;</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return (p.HasValue &amp;&amp; p.Value)?   (UInt32)1: 0;</from>
				<default              >return p.HasValue? checked((UInt32)p.Value): 0;</default>
			</group>
			<group name="SqlTypes">
				<include template ="SqlTypes"/>
				<default              >return p.IsNull? 0:        ToUInt32(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? 0: BitConverter.ToUInt32(p, 0);</from>
			</group>
			<default nullvalue="Common.Configuration.NullableValues.UInt32">
			if (p is IConvertible) return ((IConvertible)p).ToUInt32(null);
			</default>
		</converter>
		<converter type="UInt64"    nullable="false">
			<group name="Scalar Types.">
				<from type="String"   >return p == null? 0: UInt64.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Boolean"  >return (UInt64)(p? 1: 0);</from>
				<from type="Char"/>
				<default              >return checked((UInt64)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="UInt64"    >return p.HasValue?                 p.Value:  0;</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return (p.HasValue &amp;&amp; p.Value)?   (UInt64)1: 0;</from>
				<default              >return p.HasValue? checked((UInt64)p.Value): 0;</default>
			</group>
			<group name="SqlTypes">
				<include template ="SqlTypes"/>
				<default              >return p.IsNull? 0:        ToUInt64(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? 0: BitConverter.ToUInt64(p, 0);</from>
			</group>
			<default nullvalue="Common.Configuration.NullableValues.UInt64">
			if (p is IConvertible) return ((IConvertible)p).ToUInt64(null);
			</default>
		</converter>
		<br/>
		<converter type="Char"    nullable="false">
			<group name="Scalar Types.">
				<from type="String"   >return p == null? (Char)0: Char.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Boolean"  >return       (Char)(p? 1: 0);</from>
				<default              >return      checked((Char)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="Char"    >return p.HasValue?                p.Value:  (Char)0;</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Boolean"  >return (p.HasValue &amp;&amp; p.Value)?   (Char)1: (Char)0;</from>
				<default              >return p.HasValue? checked((Char)p.Value): (Char)0;</default>
			</group>
			<group name="SqlTypes">
				<include template ="SqlTypes"/>
				<default              >return p.IsNull? (Char)0:        ToChar(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? (Char)0: BitConverter.ToChar(p, 0);</from>
			</group>
			<default nullvalue="Common.Configuration.NullableValues.Char">
			if (p is IConvertible) return ((IConvertible)p).ToChar(null);
			</default>
		</converter>
		<converter type="Single"    nullable="false">
			<group name="Scalar Types.">
				<from type="String"   >return p == null? 0.0f: Single.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Boolean"  >return      p?      1.0f: 0.0f;</from>
				<from type="Char"/>
				<default              >return      checked((Single)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="Single"     >return p.HasValue?                 p.Value:  0.0f;</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return (p.HasValue &amp;&amp; p.Value)?        1.0f: 0.0f;</from>
				<default              >return p.HasValue? checked((Single)p.Value): 0.0f;</default>
			</group>
			<group name="SqlTypes">
				<from type="SqlSingle">return p.IsNull? 0.0f:                 p.Value; </from>
				<include template ="SqlTypes"/>
				<default              >return p.IsNull? 0.0f:        ToSingle(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? 0.0f: BitConverter.ToSingle(p, 0);</from>
			</group>
			<default nullvalue="Common.Configuration.NullableValues.Single">
			if (p is IConvertible) return ((IConvertible)p).ToSingle(null);
			</default>
		</converter>
		<converter type="Double"    nullable="false">
			<group name="Scalar Types.">
				<from type="String"   >return p == null? 0.0: Double.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Boolean"  >return      p?      1.0: 0.0;</from>
				<from type="Char"/>
				<from type="DateTime" >return (p - DateTime.MinValue).TotalDays;</from>
				<from type="DateTimeOffset" >return (p - DateTime.MinValue).TotalDays;</from>
				<from type="TimeSpan" >return p.TotalDays;</from>
				<default              >return      checked((Double)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="Double"     >return p.HasValue?                 p.Value:  0.0;</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return (p.HasValue &amp;&amp; p.Value)?         1.0: 0.0;</from>
				<from type="DateTime" >return p.HasValue? (p.Value - DateTime.MinValue).TotalDays: 0.0;</from>
				<from type="DateTimeOffset" >return p.HasValue? (p.Value - DateTime.MinValue).TotalDays: 0.0;</from>
				<from type="TimeSpan" >return p.HasValue? p.Value.TotalDays: 0.0;</from>
				<default              >return p.HasValue? checked((Double)p.Value):  0.0;</default>
			</group>
			<group name="SqlTypes">
				<from type="SqlDouble">return p.IsNull? 0.0:                 p.Value; </from>
				<include template ="SqlTypes"/>
				<from type="SqlDateTime"/>
				<default              >return p.IsNull? 0.0:        ToDouble(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? 0.0: BitConverter.ToDouble(p, 0);</from>
			</group>
			<default nullvalue="Common.Configuration.NullableValues.Double">
			if (p is IConvertible) return ((IConvertible)p).ToDouble(null);
			</default>
		</converter>
		<br/>
		<converter type="Boolean"  nullable="false">
			<group name="Scalar Types.">
				<from type="String">return p == null? false : p.Length == 1 ? ToBoolean(p[0]) : Boolean.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<br/>
				<from type="Char">
			switch (p)
			{
			case (Char)0: return false; // Allow int &lt;=&gt; Char &lt;=&gt; Boolean
			case     '0': return false;
			case     'n': return false;
			case     'N': return false;
			case     'f': return false;
			case     'F': return false;

			case (Char)1: return true; // Allow int &lt;=&gt; Char &lt;=&gt; Boolean
			case     '1': return true;
			case     'y': return true;
			case     'Y': return true;
			case     't': return true;
			case     'T': return true;
			}

			throw CreateInvalidCastException(typeof(Char), typeof(Boolean));</from>
				<default              >return p != 0;</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="Boolean"   >return p.HasValue? p.Value:      false;</from>
				<br/>
				<include template ="Numeric Types"/>
				<br/>
				<from type="Char"      >return p.HasValue? ToBoolean(p.Value): false;</from>
				<default               >return p.HasValue? p.Value != 0: false;</default>
			</group>
			<group name="SqlTypes">
				<from type="SqlBoolean">return p.IsNull? false:           p.Value; </from>
				<include template ="SqlTypes"/>
				<default               >return p.IsNull? false: ToBoolean(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"    >return p == null || p.Length == 0? false: BitConverter.ToBoolean(p, 0);</from>
			</group>
			<default nullvalue="Common.Configuration.NullableValues.Boolean">
			if (p is IConvertible) return ((IConvertible)p).ToBoolean(null);
			</default>
		</converter>
		<converter type="Decimal"    nullable="false">
			<group name="Scalar Types.">
				<from type="String"   >return p == null? 0.0m: Decimal.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Boolean"  >return      p?      1.0m: 0.0m;</from>
				<from type="Char"/>
				<default              >return      checked((Decimal)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="Decimal"     >return p.HasValue?                  p.Value:  0.0m;</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return (p.HasValue &amp;&amp; p.Value)?         1.0m: 0.0m;</from>
				<default              >return p.HasValue? checked((Decimal)p.Value): 0.0m;</default>
			</group>
			<group name="SqlTypes">
				<from type="SqlDecimal">return p.IsNull? 0.0m:           p.Value; </from>
				<from type="SqlMoney"  >return p.IsNull? 0.0m:           p.Value; </from>
				<include template ="SqlTypes"/>
				<default               >return p.IsNull? 0.0m: ToDecimal(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]">
					if (p == null || p.Length == 0) return 0.0m;

					int[] bits = new int[p.Length / sizeof(int)];

					Buffer.BlockCopy(p, 0, bits, 0, p.Length);
					return new Decimal(bits);</from>
			</group>
			<default nullvalue="Common.Configuration.NullableValues.Decimal">
			if (p is IConvertible) return ((IConvertible)p).ToDecimal(null);
			</default>
		</converter>
		<converter type="DateTime" nullable="false">
			<group name="Scalar Types.">
				<from type="String"   >return p == null? DateTime.MinValue: DateTime.Parse(p, null, DateTimeStyles.NoCurrentDateDefault);</from>
				<from type="TimeSpan" >return DateTime.MinValue + p;</from>
				<from type="Int64"    >return DateTime.MinValue + TimeSpan.FromTicks(p);</from>
				<from type="Double"   >return DateTime.MinValue + TimeSpan.FromDays(p);</from>
				<from type="DateTimeOffset" >return p.LocalDateTime;</from>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="DateTime"       >return p.HasValue?                                               p.Value:  DateTime.MinValue;</from>
				<from type="DateTimeOffset" >return p.HasValue?                                   p.Value.LocalDateTime:  DateTime.MinValue;</from>
				<from type="TimeSpan"       >return p.HasValue? DateTime.MinValue +                           p.Value:  DateTime.MinValue;</from>
				<from type="Int64"          >return p.HasValue? DateTime.MinValue +        TimeSpan.FromTicks(p.Value): DateTime.MinValue;</from>
				<from type="Double"         >return p.HasValue? DateTime.MinValue + TimeSpan.FromDays(p.Value): DateTime.MinValue;</from>
			</group>
			<group name="SqlTypes">
				<from type="SqlDateTime">return p.IsNull? DateTime.MinValue:                                               p.Value; </from>
				<from type="SqlString"  >return p.IsNull? DateTime.MinValue:                                    ToDateTime(p.Value);</from>
				<from type="SqlInt64"   >return p.IsNull? DateTime.MinValue: DateTime.MinValue +        TimeSpan.FromTicks(p.Value);</from>
				<from type="SqlDouble"  >return p.IsNull? DateTime.MinValue: DateTime.MinValue + TimeSpan.FromDays(p.Value);</from>
			</group>
			<group name="Other Types">
				<from type="Byte[]"     >return p == null || p.Length == 0? DateTime.MinValue: DateTime.FromBinary(ToInt64(p));</from>
			</group>
			<default nullvalue="Common.Configuration.NullableValues.DateTime">
			if (p is IConvertible) return ((IConvertible)p).ToDateTime(null);
			</default>
		</converter>
		<converter type="DateTimeOffset" nullable="false">
			<group name="Scalar Types.">
				<from type="String"   >return p == null? DateTimeOffset.MinValue: DateTimeOffset.Parse(p);</from>
				<from type="TimeSpan" >return DateTimeOffset.MinValue + p;</from>
				<from type="Int64"    >return DateTimeOffset.MinValue + TimeSpan.FromTicks(p);</from>
				<from type="Double"   >return DateTimeOffset.MinValue + TimeSpan.FromDays(p);</from>
				<from type="DateTime" >return p;</from>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="DateTimeOffset" >return p.HasValue?                                         p.Value:  DateTimeOffset.MinValue;</from>
				<from type="DateTime" >return p.HasValue?                                               p.Value:  DateTimeOffset.MinValue;</from>
				<from type="TimeSpan" >return p.HasValue? DateTimeOffset.MinValue +                           p.Value:  DateTimeOffset.MinValue;</from>
				<from type="Int64"    >return p.HasValue? DateTimeOffset.MinValue +        TimeSpan.FromTicks(p.Value): DateTimeOffset.MinValue;</from>
				<from type="Double"   >return p.HasValue? DateTimeOffset.MinValue + TimeSpan.FromDays(p.Value): DateTimeOffset.MinValue;</from>
			</group>
			<group name="SqlTypes">
				<from type="SqlDateTime">return p.IsNull? DateTimeOffset.MinValue:                                               p.Value; </from>
				<from type="SqlString"  >return p.IsNull? DateTimeOffset.MinValue:                                    ToDateTimeOffset(p.Value);</from>
				<from type="SqlInt64"   >return p.IsNull? DateTimeOffset.MinValue: DateTimeOffset.MinValue +        TimeSpan.FromTicks(p.Value);</from>
				<from type="SqlDouble"  >return p.IsNull? DateTimeOffset.MinValue: DateTimeOffset.MinValue + TimeSpan.FromDays(p.Value);</from>
			</group>
			<group name="Other Types">
				<from type="Byte[]"     >return p == null || p.Length == 0? DateTimeOffset.MinValue: new DateTimeOffset(ToDateTime(p));</from>
			</group>
			<default nullvalue="Common.Configuration.NullableValues.DateTimeOffset">
			if (p is IConvertible) return ToDateTimeOffset(((IConvertible)p).ToDateTime(null));
			</default>
		</converter>
		<converter type="TimeSpan" nullable="false">
			<group name="Scalar Types.">
				<from type="String"     >return p == null? TimeSpan.MinValue: TimeSpan.Parse(p);</from>
				<from type="DateTime"   >return p - DateTime.MinValue;</from>
				<from type="DateTimeOffset">return p - DateTimeOffset.MinValue;</from>
				<from type="Int64"      >return TimeSpan.FromTicks(p);</from>
				<from type="Double"     >return TimeSpan.FromDays(p);</from>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="TimeSpan"   >return p.HasValue? p.Value:                            TimeSpan.MinValue;</from>
				<from type="DateTime"   >return p.HasValue? p.Value - DateTime.MinValue:        TimeSpan.MinValue;</from>
				<from type="DateTimeOffset"   >return p.HasValue? p.Value - DateTimeOffset.MinValue:        TimeSpan.MinValue;</from>
				<from type="Int64"      >return p.HasValue? TimeSpan.FromTicks(p.Value):        TimeSpan.MinValue;</from>
				<from type="Double"     >return p.HasValue? TimeSpan.FromDays(p.Value): TimeSpan.MinValue;</from>
			</group>
			<group name="SqlTypes">
				<from type="SqlString"  >return p.IsNull? TimeSpan.MinValue: TimeSpan.Parse(p.Value);    </from>
				<from type="SqlDateTime">return p.IsNull? TimeSpan.MinValue: p.Value - DateTime.MinValue;</from>
				<from type="SqlInt64"   >return p.IsNull? TimeSpan.MinValue: TimeSpan.FromTicks(p.Value);</from>
				<from type="SqlDouble"  >return p.IsNull? TimeSpan.MinValue: TimeSpan.FromDays(p.Value);</from>
			</group>
			<group name="Other Types">
				<from type="Byte[]"     >return p == null || p.Length == 0? TimeSpan.MinValue: TimeSpan.FromTicks(ToInt64(p));</from>
			</group>
			<default nullvalue="Common.Configuration.NullableValues.TimeSpan"/>
		</converter>
		<converter type="Guid"     nullable="false">
			<group name="Scalar Types.">
				<from type="String"   >return p == null? Guid.Empty: new Guid(p);</from>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="Guid"    >return p.HasValue? p.Value: Guid.Empty;</from>
			</group>
			<group name="SqlTypes">
				<from type="SqlGuid"  >return p.IsNull? Guid.Empty: p.Value;            </from>
				<from type="SqlString">return p.IsNull? Guid.Empty: new Guid(p.Value);  </from>
				<from type="SqlBinary">return p.IsNull? Guid.Empty: p.ToSqlGuid().Value;</from>
			</group>
			<group name="Other Types.">
				<from type="Byte[]"   >return p == null? Guid.Empty: new Guid(p);</from>
				<from type="Type"     >return p == null? Guid.Empty: p.GUID;</from>
			</group>
			<default nullvalue="Common.Configuration.NullableValues.Guid"/>
		</converter>
	</region>
	<region name="Nullable Types">
		<converter type="SByte"    nullable="true">
			<group name="Scalar Types.">
				<from type="SByte"  >return p;</from>
				<from type="String" >return p == null? null: (SByte?)SByte.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean">return       (SByte?)(p? 1: 0);</from>
				<default            >return      checked((SByte?)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean">return p.HasValue? (SByte?)(p.Value? 1: 0):  null;</from>
				<default            >return p.HasValue? checked((SByte?)p.Value): null;</default>
			</group>
			<group name="SqlTypes">
				<include template ="SqlTypes"/>
				<default              >return p.IsNull? null: ToNullableSByte(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? null: (SByte?)ToSByte(p);</from>
			</group>
			<default nullvalue="null">
			if (p is IConvertible) return ((IConvertible)p).ToSByte(null);
			</default>
		</converter>
		<converter type="Int16"    nullable="true">
			<group name="Scalar Types.">
				<from type="Int16"  >return p;</from>
				<from type="String" >return p == null? null: (Int16?)Int16.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean">return       (Int16?)(p? 1: 0);</from>
				<default            >return      checked((Int16?)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean">return p.HasValue? (Int16?)(p.Value? 1: 0):  null;</from>
				<default            >return p.HasValue? checked((Int16?)p.Value): null;</default>
			</group>
			<group name="SqlTypes">
				<from type="SqlInt16" >return p.IsNull? null:         (Int16?)p.Value; </from>
				<include template ="SqlTypes"/>
				<default              >return p.IsNull? null: ToNullableInt16(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? null: (Int16?)ToInt16(p);</from>
			</group>
			<default nullvalue="null">
			if (p is IConvertible) return ((IConvertible)p).ToInt16(null);
			</default>
		</converter>
		<converter type="Int32"    nullable="true">
			<group name="Scalar Types.">
				<from type="Int32"  >return p;</from>
				<from type="String" >return p == null? null: (Int32?)Int32.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean">return p? 1: 0;</from>
				<default            >return checked((Int32?)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean">return p.HasValue? (Int32?)(p.Value? 1: 0):  null;</from>
				<default            >return p.HasValue? checked((Int32?)p.Value): null;</default>
			</group>
			<group name="SqlTypes">
				<from type="SqlInt32" >return p.IsNull? null:         (Int32?)p.Value; </from>
				<include template ="SqlTypes"/>
				<default              >return p.IsNull? null: ToNullableInt32(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? null: (Int32?)ToInt32(p);</from>
			</group>
			<default nullvalue="null">
			if (p is IConvertible) return ((IConvertible)p).ToInt32(null);
			</default>
		</converter>
		<converter type="Int64"    nullable="true">
			<group name="Scalar Types.">
				<from type="Int64"   >return p;</from>
				<from type="String"  >return p == null? null: (Int64?)Int64.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean" >return p? 1: 0;</from>
				<from type="DateTime">return (p - DateTime.MinValue).Ticks;</from>
				<from type="DateTimeOffset">return (p - DateTimeOffset.MinValue).Ticks;</from>
				<from type="TimeSpan">return p.Ticks;</from>
				<default             >return checked((Int64?)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean">return p.HasValue? (Int64?)(p.Value? 1: 0):  null;</from>
				<from type="DateTime">return p.HasValue? (Int64?)(p.Value - DateTime.MinValue).Ticks: null;</from>
				<from type="DateTimeOffset">return p.HasValue? (Int64?)(p.Value - DateTimeOffset.MinValue).Ticks: null;</from>
				<from type="TimeSpan">return p.HasValue? (Int64?)p.Value.Ticks: null;</from>
				<default             >return p.HasValue? checked((Int64?)p.Value): null;</default>
			</group>
			<group name="SqlTypes">
				<from type="SqlInt64">return p.IsNull? null:         (Int64?)p.Value; </from>
				<include template ="SqlTypes"/>
				<from type="SqlDateTime"/>
				<default             >return p.IsNull? null: ToNullableInt64(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"  >return p == null || p.Length == 0? null: (Int64?)ToInt64(p);</from>
			</group>
			<default nullvalue="null">
			if (p is IConvertible) return ((IConvertible)p).ToInt64(null);
			</default>
		</converter>
		<br/>
		<converter type="Byte"    nullable="true">
			<group name="Scalar Types.">
				<from type="Byte"   >return p;</from>
				<from type="String" >return p == null? null: (Byte?)Byte.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean">return       (Byte?)(p? 1: 0);</from>
				<default            >return      checked((Byte?)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean">return p.HasValue? (Byte?)(p.Value? 1: 0):  null;</from>
				<default            >return p.HasValue? checked((Byte?)p.Value): null;</default>
			</group>
			<group name="SqlTypes">
				<from type="SqlByte" >return p.IsNull? null:         (Byte?)p.Value; </from>
				<include template ="SqlTypes"/>
				<default             >return p.IsNull? null: ToNullableByte(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"  >return p == null || p.Length == 0? null: (Byte?)ToByte(p);</from>
			</group>
			<default nullvalue="null">
			if (p is IConvertible) return ((IConvertible)p).ToByte(null);
			</default>
		</converter>
		<converter type="UInt16"    nullable="true">
			<group name="Scalar Types.">
				<from type="UInt16" >return p;</from>
				<from type="String" >return p == null? null: (UInt16?)UInt16.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean">return       (UInt16?)(p? 1: 0);</from>
				<default            >return      checked((UInt16?)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean">return p.HasValue? (UInt16?)(p.Value? 1: 0):  null;</from>
				<default            >return p.HasValue? checked((UInt16?)p.Value): null;</default>
			</group>
			<group name="SqlTypes">
				<include template ="SqlTypes"/>
				<default            >return p.IsNull? null: ToNullableUInt16(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]" >return p == null || p.Length == 0? null: (UInt16?)ToUInt16(p);</from>
			</group>
			<default nullvalue="null">
			if (p is IConvertible) return ((IConvertible)p).ToUInt16(null);
			</default>
		</converter>
		<converter type="UInt32"    nullable="true">
			<group name="Scalar Types.">
				<from type="UInt32" >return p;</from>
				<from type="String" >return p == null? null: (UInt32?)UInt32.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean">return       (UInt32?)(p? 1: 0);</from>
				<default            >return      checked((UInt32?)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean">return p.HasValue? (UInt32?)(p.Value? 1: 0):  null;</from>
				<default            >return p.HasValue? checked((UInt32?)p.Value): null;</default>
			</group>
			<group name="SqlTypes">
				<include template ="SqlTypes"/>
				<default            >return p.IsNull? null: ToNullableUInt32(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]" >return p == null || p.Length == 0? null: (UInt32?)ToUInt32(p);</from>
			</group>
			<default nullvalue="null">
			if (p is IConvertible) return ((IConvertible)p).ToUInt32(null);
			</default>
		</converter>
		<converter type="UInt64"    nullable="true">
			<group name="Scalar Types.">
				<from type="UInt64" >return p;</from>
				<from type="String" >return p == null? null: (UInt64?)UInt64.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean" >return (UInt64?)(p? 1: 0);</from>
				<default             >return checked((UInt64?)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean" >return p.HasValue? (UInt64?)(p.Value? 1: 0):  null;</from>
				<default             >return p.HasValue? checked((UInt64?)p.Value): null;</default>
			</group>
			<group name="SqlTypes">
				<include template ="SqlTypes"/>
				<default             >return p.IsNull? null: ToNullableUInt64(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"  >return p == null || p.Length == 0? null: (UInt64?)ToUInt64(p);</from>
			</group>
			<default nullvalue="null">
			if (p is IConvertible) return ((IConvertible)p).ToUInt64(null);
			</default>
		</converter>
		<br/>
		<converter type="Char"     nullable="true">
			<group name="Scalar Types.">
				<from type="Char"  >return p;</from>
				<from type="String">return p == null? null: (Char?)Char.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Boolean">return (Char?)(p? 1: 0);</from>
				<default            >return checked((Char?)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<include template ="Numeric Types"/>
				<from type="Boolean"  >return p.HasValue?  (Char?)(p.Value? 1: 0): null;</from>
				<default              >return p.HasValue? checked((Char?)p.Value): null;</default>
			</group>
			<group name="SqlTypes">
				<include template ="SqlTypes"/>
				<default               >return p.IsNull? null: ToNullableChar(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"    >return p == null || p.Length == 0? null: (Char?)ToChar(p);</from>
			</group>
			<default nullvalue="null">
			if (p is IConvertible) return ((IConvertible)p).ToChar(null);
			</default>
		</converter>
		<converter type="Single"    nullable="true">
			<group name="Scalar Types.">
				<from type="Single" >return p;</from>
				<from type="String" >return p == null? null: (Single?)Single.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean">return p? 1.0f: 0.0f;</from>
				<default            >return checked((Single?)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean">return p.HasValue? (Single?)(p.Value? 1.0f: 0.0f):  null;</from>
				<default            >return p.HasValue? checked((Single?)p.Value): null;</default>
			</group>
			<group name="SqlTypes">
				<from type="SqlSingle" >return p.IsNull? null:         (Single?)p.Value; </from>
				<include template ="SqlTypes"/>
				<default             >return p.IsNull? null: ToNullableSingle(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"  >return p == null || p.Length == 0? null: (Single?)ToSingle(p);</from>
			</group>
			<default nullvalue="null">
			if (p is IConvertible) return ((IConvertible)p).ToSingle(null);
			</default>
		</converter>
		<converter type="Double"    nullable="true">
			<group name="Scalar Types.">
				<from type="Double"   >return p;</from>
				<from type="String"   >return p == null? null: (Double?)Double.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return p? 1.0: 0.0;</from>
				<from type="DateTime" >return (p - DateTime.MinValue).TotalDays;</from>
				<from type="DateTimeOffset" >return (p - DateTimeOffset.MinValue).TotalDays;</from>
				<from type="TimeSpan" >return p.TotalDays;</from>
				<default              >return checked((Double?)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return p.HasValue? (Double?)(p.Value? 1.0: 0.0):  null;</from>
				<from type="DateTime" >return p.HasValue? (Double?)(p.Value - DateTime.MinValue).TotalDays: null;</from>
				<from type="DateTimeOffset" >return p.HasValue? (Double?)(p.Value - DateTimeOffset.MinValue).TotalDays: null;</from>
				<from type="TimeSpan" >return p.HasValue? (Double?)p.Value.TotalDays: null;</from>
				<default              >return p.HasValue? checked((Double?)p.Value): null;</default>
			</group>
			<group name="SqlTypes">
				<from type="SqlDouble">return p.IsNull? null:         (Double?)p.Value; </from>
				<include template ="SqlTypes"/>
				<from type="SqlDateTime">return p.IsNull? null: (Double?)(p.Value - DateTime.MinValue).TotalDays;</from>
				<default              >return p.IsNull? null: ToNullableDouble(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? null: (Double?)ToDouble(p);</from>
			</group>
			<default nullvalue="null">
			if (p is IConvertible) return ((IConvertible)p).ToDouble(null);
			</default>
		</converter>
		<br/>
		<converter type="Boolean"  nullable="true">
			<group name="Scalar Types.">
				<from type="Boolean"   >return p;</from>
				<from type="String"    >return p == null? null: (Boolean?)Boolean.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"     />
				<default               >return ToBoolean(p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<include template ="Numeric Types"/>
				<from type="Char"     />
				<default               >return p.HasValue? (Boolean?)ToBoolean(p.Value): null;</default>
			</group>
			<group name="SqlTypes">
				<from type="SqlBoolean">return p.IsNull? null: (Boolean?)          p.Value; </from>
				<include template ="SqlTypes"/>
				<default               >return p.IsNull? null: (Boolean?)ToBoolean(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"    >return p == null || p.Length == 0? null: (Boolean?)ToBoolean(p);</from>
			</group>
			<default nullvalue="null">
			if (p is IConvertible) return ((IConvertible)p).ToBoolean(null);
			</default>
		</converter>
		<converter type="Decimal"    nullable="true">
			<group name="Scalar Types.">
				<from type="Decimal" >return p;</from>
				<from type="String" >return p == null? null: (Decimal?)Decimal.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean">return p? 1.0m: 0.0m;</from>
				<default            >return checked((Decimal?)p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean">return p.HasValue? (Decimal?)(p.Value? 1.0m: 0.0m):  null;</from>
				<default            >return p.HasValue? checked((Decimal?)p.Value): null;</default>
			</group>
			<group name="SqlTypes">
				<from type="SqlDecimal">return p.IsNull? null:         (Decimal?)p.Value; </from>
				<from type="SqlMoney"  >return p.IsNull? null:         (Decimal?)p.Value; </from>
				<include template ="SqlTypes"/>
				<default               >return p.IsNull? null: ToNullableDecimal(p.Value);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"    >return p == null || p.Length == 0? null: (Decimal?)ToDecimal(p);</from>
			</group>
			<default nullvalue="null">
			if (p is IConvertible) return ((IConvertible)p).ToDecimal(null);
			</default>
		</converter>
		<converter type="DateTime" nullable="true">
			<group name="Scalar Types.">
				<from type="DateTime">return p;</from>
				<from type="DateTimeOffset">return p.LocalDateTime;</from>
				<from type="String"  >return p == null? null: (DateTime?)DateTime.Parse(p);</from>
				<br/>
				<from type="TimeSpan" >return DateTime.MinValue + p;</from>
				<from type="Int64"    >return DateTime.MinValue + TimeSpan.FromTicks(p);</from>
				<from type="Double"   >return DateTime.MinValue + TimeSpan.FromDays(p);</from>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="TimeSpan" >return p.HasValue? DateTime.MinValue +                           p.Value:  (DateTime?)null;</from>
				<from type="Int64"    >return p.HasValue? DateTime.MinValue +        TimeSpan.FromTicks(p.Value): (DateTime?)null;</from>
				<from type="Double"   >return p.HasValue? DateTime.MinValue + TimeSpan.FromDays(p.Value): (DateTime?)null;</from>
				<from type="DateTimeOffset">return p.HasValue? p.Value.LocalDateTime: (DateTime?)null;</from>
			</group>
			<group name="SqlTypes">
				<from type="SqlDateTime">return p.IsNull? (DateTime?)null:                                               p.Value; </from>
				<from type="SqlString"  >return p.IsNull? (DateTime?)null:                                    ToDateTime(p.Value);</from>
				<from type="SqlInt64"   >return p.IsNull? (DateTime?)null: DateTime.MinValue +        TimeSpan.FromTicks(p.Value);</from>
				<from type="SqlDouble"  >return p.IsNull? (DateTime?)null: DateTime.MinValue + TimeSpan.FromDays(p.Value);</from>
			</group>
			<group name="Other Types">
				<from type="Byte[]"     >return p == null || p.Length == 0? null: (DateTime?)ToDateTime(p);</from>
			</group>
			<default nullvalue="null">
			if (p is IConvertible) return ((IConvertible)p).ToDateTime(null);
			</default>
		</converter>
		<converter type="DateTimeOffset" nullable="true">
			<group name="Scalar Types.">
				<from type="DateTime">return p;</from>
				<from type="DateTimeOffset">return p;</from>
				<from type="String"  >return p == null? null: (DateTimeOffset?)DateTimeOffset.Parse(p);</from>
				<br/>
				<from type="TimeSpan" >return DateTimeOffset.MinValue + p;</from>
				<from type="Int64"    >return DateTimeOffset.MinValue + TimeSpan.FromTicks(p);</from>
				<from type="Double"   >return DateTimeOffset.MinValue + TimeSpan.FromDays(p);</from>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="TimeSpan" >return p.HasValue? DateTimeOffset.MinValue +                           p.Value:  (DateTimeOffset?)null;</from>
				<from type="Int64"    >return p.HasValue? DateTimeOffset.MinValue +        TimeSpan.FromTicks(p.Value): (DateTimeOffset?)null;</from>
				<from type="Double"   >return p.HasValue? DateTimeOffset.MinValue + TimeSpan.FromDays(p.Value): (DateTimeOffset?)null;</from>
				<from type="DateTime">return p.HasValue? p: null;</from>
			</group>
			<group name="SqlTypes">
				<from type="SqlDateTime">return p.IsNull? (DateTimeOffset?)null:                                               p.Value; </from>
				<from type="SqlString"  >return p.IsNull? (DateTimeOffset?)null:                                    ToDateTimeOffset(p.Value);</from>
				<from type="SqlInt64"   >return p.IsNull? (DateTimeOffset?)null: DateTimeOffset.MinValue +        TimeSpan.FromTicks(p.Value);</from>
				<from type="SqlDouble"  >return p.IsNull? (DateTimeOffset?)null: DateTimeOffset.MinValue + TimeSpan.FromDays(p.Value);</from>
			</group>
			<group name="Other Types">
				<from type="Byte[]"     >return p == null || p.Length == 0? null: (DateTimeOffset?)ToDateTimeOffset(p);</from>
			</group>
			<default nullvalue="null">
			if (p is IConvertible) return ToDateTimeOffset(((IConvertible)p).ToDateTime(null));
			</default>
		</converter>
		<converter type="TimeSpan" nullable="true">
			<group name="Scalar Types.">
				<from type="TimeSpan"   >return p;</from>
				<from type="String"     >return p == null? null: (TimeSpan?)TimeSpan.Parse(p);</from>
				<from type="DateTime"   >return p - DateTime.MinValue;</from>
				<from type="DateTimeOffset">return p - DateTimeOffset.MinValue;</from>
				<from type="Int64"      >return TimeSpan.FromTicks(p);</from>
				<from type="Double"     >return TimeSpan.FromDays(p);</from>
			</group>

			<group name="Nullable Types." nullable="true">
				<from type="DateTime"   >return p.HasValue? p.Value - DateTime.MinValue: (TimeSpan?)null;</from>
				<from type="DateTimeOffset"   >return p.HasValue? p.Value - DateTimeOffset.MinValue: (TimeSpan?)null;</from>
				<from type="Int64"      >return p.HasValue? TimeSpan.FromTicks(p.Value): (TimeSpan?)null;</from>
				<from type="Double"     >return p.HasValue? TimeSpan.FromDays(p.Value): (TimeSpan?)null;</from>
			</group>

			<group name="SqlTypes">
				<from type="SqlString"  >return p.IsNull? (TimeSpan?)null: TimeSpan.Parse(p.Value);    </from>
				<from type="SqlDateTime">return p.IsNull? (TimeSpan?)null: p.Value - DateTime.MinValue;</from>
				<from type="SqlInt64"   >return p.IsNull? (TimeSpan?)null: TimeSpan.FromTicks(p.Value);</from>
				<from type="SqlDouble"  >return p.IsNull? (TimeSpan?)null: TimeSpan.FromDays(p.Value);</from>
			</group>
			<group name="Other Types">
				<from type="Byte[]"     >return p == null || p.Length == 0? null: (TimeSpan?)ToTimeSpan(p);</from>
			</group>
			<default nullvalue="null"/>
		</converter>
		<converter type="Guid"     nullable="true">
			<group name="Scalar Types.">
				<from type="Guid"     >return p;</from>
				<from type="String"   >return p == null? null: (Guid?)new Guid(p);</from>
			</group>
			<group name="SqlTypes">
				<from type="SqlGuid"  >return p.IsNull? null: (Guid?)p.Value;            </from>
				<from type="SqlString">return p.IsNull? null: (Guid?)new Guid(p.Value);  </from>
				<from type="SqlBinary">return p.IsNull? null: (Guid?)p.ToSqlGuid().Value;</from>
			</group>
			<group name="Other Types.">
				<from type="Type"     >return p == null? null: (Guid?)p.GUID;</from>
				<from type="Byte[]"   >return p == null? null: (Guid?)new Guid(p);</from>
			</group>
			<default nullvalue="null"/>
		</converter>
	</region>
	<region name="SqlTypes">
		<converter type="SqlString">
			<group name="Scalar Types.">
				<from type="String"   >return p ?? SqlString.Null;</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"    />
				<from type="TimeSpan"/>
				<from type="DateTime"/>
				<from type="DateTimeOffset"/>
				<from type="Guid"    />
				<from type="Char[]"   >return new String(p);</from>
				<default              >return p.ToString();</default>
			</group>

			<group name="Nullable Types." nullable="true">
				<include template ="Numeric Types"/>
				<from type="Char"    />
				<from type="TimeSpan"/>
				<from type="DateTime"/>
				<from type="DateTimeOffset"/>
				<from type="Guid"    />
				<default              >return p.HasValue? p.ToString(): SqlString.Null;</default>
			</group>

			<group name="SqlTypes">
				<include template="SqlTypes"/>
				<from type="SqlChars"/>
				<from type="SqlXml">return p.IsNull? SqlString.Null: p.Value;</from>
				<from type="SqlGuid" />
				<from type="SqlDateTime"/>
				<default              >return p.ToSqlString();</default>
			</group>
			<group name="Other Types">
				<from type="Type"       >return p == null? SqlString.Null: p.FullName;</from>
				<from type="XmlDocument">return p == null? SqlString.Null: p.InnerXml;</from>
				<from type="Byte[]"     >return p == null || p.Length == 0? SqlString.Null: new SqlString(ToString(p));</from>
			</group>
			<default nullvalue="SqlString.Null" nothrow="true">
			return ToString(p);</default>
		</converter>
		<br/>
		<converter type="SqlByte">
			<group name="Scalar Types.">
				<from type="Byte"     >return p;</from>
				<from type="String"   >return p == null? SqlByte.Null: SqlByte.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return (Byte)(p? 1: 0);</from>
				<default              >return checked((Byte)p);</default>
			</group>

			<group name="Nullable Types." nullable="true">
				<from type="Byte"     >return p.HasValue?        p.Value:  SqlByte.Null;</from>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<default              >return p.HasValue? ToByte(p.Value): SqlByte.Null;</default>
			</group>

			<group name="SqlTypes">
				<include template="SqlTypes"/>
				<from type="SqlDateTime">return p.IsNull? SqlByte.Null: ToByte(p.Value);</from>
				<default              >return p.ToSqlByte();</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? SqlByte.Null: new SqlByte(ToByte(p));</from>
			</group>
			<default nullvalue="SqlByte.Null" nothrow="true">
			return ToByte(p);</default>
		</converter>
		<converter type="SqlInt16">
			<group name="Scalar Types.">
				<from type="Int16"    >return p;</from>
				<from type="String"   >return p == null? SqlInt16.Null: SqlInt16.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return (Int16)(p? 1: 0);</from>
				<default              >return checked((Int16)p);</default>
			</group>

			<group name="Nullable Types." nullable="true">
				<from type="Int16"   >return p.HasValue?         p.Value:  SqlInt16.Null;</from>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<default             >return p.HasValue? ToInt16(p.Value): SqlInt16.Null;</default>
			</group>

			<group name="SqlTypes">
				<include template="SqlTypes"/>
				<from type="SqlDateTime">return p.IsNull? SqlInt16.Null: ToInt16(p.Value);</from>
				<default                >return p.ToSqlInt16();</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"     >return p == null || p.Length == 0? SqlInt16.Null: new SqlInt16(ToInt16(p));</from>
			</group>
			<default nullvalue="SqlInt16.Null" nothrow="true">
			return ToInt16(p);</default>
		</converter>
		<converter type="SqlInt32">
			<group name="Scalar Types.">
				<from type="Int32"    >return p;</from>
				<from type="String"   >return p == null? SqlInt32.Null: SqlInt32.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return p? 1: 0;</from>
				<default              >return checked((Int32)p);</default>
			</group>

			<group name="Nullable Types." nullable="true">
				<from type="Int32"   >return p.HasValue?         p.Value:  SqlInt32.Null;</from>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<default             >return p.HasValue? ToInt32(p.Value): SqlInt32.Null;</default>
			</group>

			<group name="SqlTypes">
				<include template="SqlTypes"/>
				<from type="SqlDateTime">return p.IsNull? SqlInt32.Null: ToInt32(p.Value);</from>
				<default                >return p.ToSqlInt32();</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"     >return p == null || p.Length == 0? SqlInt32.Null: new SqlInt32(ToInt32(p));</from>
			</group>
			<default nullvalue="SqlInt32.Null" nothrow="true">
			return ToInt32(p);</default>
		</converter>
		<converter type="SqlInt64">
			<group name="Scalar Types.">
				<from type="Int64"    >return p;</from>
				<from type="String"   >return p == null? SqlInt64.Null: SqlInt64.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return p? 1: 0;</from>
				<from type="DateTime" >return (p - DateTime.MinValue).Ticks;</from>
				<from type="DateTimeOffset" >return (p - DateTimeOffset.MinValue).Ticks;</from>
				<from type="TimeSpan" >return p.Ticks;</from>
				<default              >return checked((Int64)p);</default>
			</group>

			<group name="Nullable Types." nullable="true">
				<from type="Int64"   >return p.HasValue?         p.Value:  SqlInt64.Null;</from>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="DateTime"/>
				<from type="DateTimeOffset"/>
				<from type="TimeSpan"/>
				<default             >return p.HasValue? ToInt64(p.Value): SqlInt64.Null;</default>
			</group>

			<group name="SqlTypes">
				<include template="SqlTypes"/>
				<from type="SqlDateTime">return p.IsNull? SqlInt64.Null: ToInt64(p.Value);</from>
				<default              >return p.ToSqlInt64();</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? SqlInt64.Null: new SqlInt64(ToInt64(p));</from>
			</group>
			<default nullvalue="SqlInt64.Null" nothrow="true">
			return ToInt64(p);</default>
		</converter>
		<br/>
		<converter type="SqlSingle">
			<group name="Scalar Types.">
				<from type="Single"   >return p;</from>
				<from type="String"   >return p == null? SqlSingle.Null: SqlSingle.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return p? 1.0f: 0.0f;</from>
				<default              >return checked((Single)p);</default>
			</group>

			<group name="Nullable Types." nullable="true">
				<from type="Single"  >return p.HasValue?          p.Value:  SqlSingle.Null;</from>
				<include template ="Numeric Types"/>
				<default             >return p.HasValue? ToSingle(p.Value): SqlSingle.Null;</default>
			</group>

			<group name="SqlTypes">
				<include template="SqlTypes"/>
				<default              >return p.ToSqlSingle();</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? SqlSingle.Null: new SqlSingle(ToSingle(p));</from>
			</group>
			<default nullvalue="SqlSingle.Null" nothrow="true">
			return ToSingle(p);</default>
		</converter>
		<converter type="SqlDouble">
			<group name="Scalar Types.">
				<from type="Double"   >return p;</from>
				<from type="String"   >return p == null? SqlDouble.Null: SqlDouble.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return p? 1.0: 0.0;</from>
				<from type="DateTime" >return (p - DateTime.MinValue).TotalDays;</from>
				<from type="DateTimeOffset" >return (p - DateTimeOffset.MinValue).TotalDays;</from>
				<from type="TimeSpan" >return p.TotalDays;</from>
				<default              >return checked((Double)p);</default>
			</group>

			<group name="Nullable Types." nullable="true">
				<from type="Double"  >return p.HasValue?          p.Value:  SqlDouble.Null;</from>
				<include template ="Numeric Types"/>
				<from type="DateTime"/>
				<from type="DateTimeOffset"/>
				<from type="TimeSpan"/>
				<default             >return p.HasValue? ToDouble(p.Value): SqlDouble.Null;</default>
			</group>

			<group name="SqlTypes">
				<include template="SqlTypes"/>
				<from type="SqlDateTime">return p.IsNull? SqlDouble.Null: ToDouble(p.Value);</from>
				<default              >return p.ToSqlDouble();</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? SqlDouble.Null: new SqlDouble(ToDouble(p));</from>
			</group>
			<default nullvalue="SqlDouble.Null" nothrow="true">
			return ToDouble(p);</default>
		</converter>
		<converter type="SqlDecimal">
			<group name="Scalar Types.">
				<from type="Decimal"  >return p;</from>
				<from type="String"   >return p == null? SqlDecimal.Null: SqlDecimal.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return p? 1.0m: 0.0m;</from>
				<default              >return checked((Decimal)p);</default>
			</group>

			<group name="Nullable Types." nullable="true">
				<from type="Decimal" >return p.HasValue?           p.Value:  SqlDecimal.Null;</from>
				<include template ="Numeric Types"/>
				<default             >return p.HasValue? ToDecimal(p.Value): SqlDecimal.Null;</default>
			</group>

			<group name="SqlTypes">
				<include template="SqlTypes"/>
				<default              >return p.ToSqlDecimal();</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? SqlDecimal.Null: new SqlDecimal(ToDecimal(p));</from>
			</group>
			<default nullvalue="SqlDecimal.Null" nothrow="true">
			return ToDecimal(p);</default>
		</converter>
		<converter type="SqlMoney">
			<group name="Scalar Types.">
				<from type="Decimal"  >return p;</from>
				<from type="String"   >return p == null? SqlMoney.Null: SqlMoney.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="Boolean"  >return p? 1.0m: 0.0m;</from>
				<default              >return checked((Decimal)p);</default>
			</group>

			<group name="Nullable Types." nullable="true">
				<from type="Decimal" >return p.HasValue?           p.Value:  SqlMoney.Null;</from>
				<include template ="Numeric Types"/>
				<default             >return p.HasValue? ToDecimal(p.Value): SqlMoney.Null;</default>
			</group>

			<group name="SqlTypes">
				<include template="SqlTypes"/>
				<default              >return p.ToSqlMoney();</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? SqlMoney.Null: new SqlMoney(ToDecimal(p));</from>
			</group>
			<default nullvalue="SqlMoney.Null" nothrow="true">
			return ToDecimal(p);</default>
		</converter>
		<br/>
		<converter type="SqlBoolean">
			<group name="Scalar Types.">
				<from type="Boolean"  >return p;</from>
				<from type="String"   >return p == null? SqlBoolean.Null: SqlBoolean.Parse(p);</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<default              >return p != 0;</default>
			</group>

			<group name="Nullable Types." nullable="true">
				<from type="Boolean" >return p.HasValue?           p.Value:  SqlBoolean.Null;</from>
				<include template ="Numeric Types"/>
				<from type="Char"   />
				<default             >return p.HasValue? ToBoolean(p.Value): SqlBoolean.Null;</default>
			</group>

			<group name="SqlTypes">
				<include template="SqlTypes"/>
				<default              >return p.ToSqlBoolean();</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? SqlBoolean.Null: new SqlBoolean(ToBoolean(p));</from>
			</group>
			<default nullvalue="SqlBoolean.Null" nothrow="true">
			return ToBoolean(p);</default>
		</converter>
		<converter type="SqlDateTime">
			<group name="Scalar Types.">
				<from type="String"   >return p == null? SqlDateTime.Null: SqlDateTime.Parse(p);</from>
				<from type="DateTime" >return p;</from>
				<from type="DateTimeOffset" >return p.LocalDateTime;</from>
				<from type="TimeSpan"/>
				<from type="Int64"/>
				<from type="Double"/>
				<default              >return ToDateTime(p);</default>
			</group>

			<group name="Nullable Types." nullable="true">
				<from type="DateTime">return p.HasValue?            p.Value:  SqlDateTime.Null;</from>
				<from type="DateTimeOffset">return p.HasValue?            p.Value.LocalDateTime:  SqlDateTime.Null;</from>
				<from type="TimeSpan"/>
				<from type="Int64"/>
				<from type="Double"/>
				<default             >return p.HasValue? ToDateTime(p.Value): SqlDateTime.Null;</default>
			</group>

			<group name="SqlTypes">
				<from type="SqlString">return p.ToSqlDateTime();</from>
				<from type="SqlInt64"/>
				<from type="SqlDouble"/>
				<default              >return p.IsNull? SqlDateTime.Null: ToDateTime(p);</default>
			</group>
			<group name="Other Types">
				<from type="Byte[]"   >return p == null || p.Length == 0? SqlDateTime.Null: new SqlDateTime(ToDateTime(p));</from>
			</group>
			<default nullvalue="SqlDateTime.Null" nothrow="true">
			return ToDateTime(p);</default>
		</converter>
		<converter type="SqlGuid">
			<group name="Scalar Types.">
				<from type="Guid"     >return p;</from>
				<from type="String"   >return p == null? SqlGuid.Null: SqlGuid.Parse(p);</from>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="Guid"    >return p.HasValue? p.Value: SqlGuid.Null;</from>
			</group>
			<group name="SqlTypes">
				<from type="SqlBinary"/>
				<from type="SqlBytes" >return p.ToSqlBinary().ToSqlGuid();</from>
				<from type="SqlString"/>
				<default              >return p.ToSqlGuid();</default>
			</group>
			<group name="Other Types.">
				<from type="Type"         >return p == null? SqlGuid.Null: p.GUID;</from>
				<from type="Byte[]"       >return p == null? SqlGuid.Null: new SqlGuid(p);</from>
			</group>
			<default nullvalue="SqlGuid.Null" nothrow="true">
			return ToGuid(p);</default>
		</converter>
		<converter type="SqlBinary">
			<group name="Scalar Types.">
				<from type="Byte[]"   >return p;</from>
				<from type="Guid"     >return p == Guid.Empty? SqlBinary.Null: new SqlGuid(p).ToSqlBinary();</from>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="Guid"    >return p.HasValue? new SqlGuid(p.Value).ToSqlBinary(): SqlBinary.Null;</from>
			</group>
			<group name="SqlTypes">
				<from type="SqlBytes"/>
				<from type="SqlGuid"/>
				<default              >return p.ToSqlBinary();</default>
			</group>
			<default nullvalue="SqlBinary.Null" nothrow="true">
			return ToByteArray(p);</default>
		</converter>
		<converter type="SqlBytes">
			<group name="Scalar Types.">
				<from type="Byte[]" >return p == null? SqlBytes.Null: new SqlBytes(p);</from>
				<from type="Stream" >return p == null? SqlBytes.Null: new SqlBytes(p);</from>
				<from type="Guid"   >return p == Guid.Empty? SqlBytes.Null: new SqlBytes(p.ToByteArray());</from>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="Guid"   >return p.HasValue? new SqlBytes(p.Value.ToByteArray()): SqlBytes.Null;</from>
			</group>
			<group name="SqlTypes">
				<from type="SqlBinary">return p.IsNull? SqlBytes.Null: new SqlBytes(p);</from>
				<from type="SqlGuid"  >return p.IsNull? SqlBytes.Null: new SqlBytes(p.ToByteArray());</from>
			</group>
			<default nullvalue="SqlBytes.Null" nothrow="true">
			return new SqlBytes(ToByteArray(p));</default>
		</converter>
		<converter type="SqlChars">
			<group name="Scalar Types.">
				<from type="String">return p == null? SqlChars.Null: new SqlChars(p.ToCharArray());</from>
				<from type="Char[]">return p == null? SqlChars.Null: new SqlChars(p);</from>
				<from type="Byte[]">return p == null? SqlChars.Null: new SqlChars(ToCharArray(p));</from>
				<br/>
				<include template ="Numeric Types"/>
				<from type="Char"/>
				<from type="TimeSpan"/>
				<from type="DateTime"/>
				<from type="DateTimeOffset"/>
				<from type="Guid"    />
				<default>return new SqlChars(ToString(p).ToCharArray());</default>
			</group>

			<group name="Nullable Types." nullable="true">
				<include template ="Numeric Types"/>
				<from type="Char"     >return p.HasValue? new SqlChars(new Char[]{p.Value})       : SqlChars.Null;</from>
				<from type="TimeSpan"/>
				<from type="DateTime"/>
				<from type="DateTimeOffset"/>
				<from type="Guid"    />
				<default              >return p.HasValue? new SqlChars(p.ToString().ToCharArray()): SqlChars.Null;</default>
			</group>

			<group name="SqlTypes">
				<from type="SqlString">return (SqlChars)p;</from>
				<include template="SqlTypes"/>
				<from type="SqlGuid" />
				<from type="SqlDateTime" />
				<from type="SqlBinary">return p.IsNull? SqlChars.Null: new SqlChars(p.ToString().ToCharArray());</from>
				<default              >return (SqlChars)p.ToSqlString();</default>
			</group>
			<from type="Type"         >return p == null? SqlChars.Null: new SqlChars(p.FullName.ToCharArray());</from>
			<default nullvalue="SqlChars.Null" nothrow="true">
			return new SqlChars(ToString(p).ToCharArray());</default>
		</converter>
		<converter type="SqlXml">
			<group name="Scalar Types.">
				<from type="String"    >return p == null? SqlXml.Null: new SqlXml(new XmlTextReader(new StringReader(p)));</from>
				<br/>
				<from type="Stream"   />
				<from type="XmlReader"/>
        <from type="XmlDocument">return p == null? SqlXml.Null: new SqlXml(new XmlTextReader(new StringReader(p.InnerXml)));</from>
				<br/>
				<from type="Char[]"    >return p == null? SqlXml.Null: new SqlXml(new XmlTextReader(new StringReader(new string(p))));</from>
				<from type="Byte[]"    >return p == null? SqlXml.Null: new SqlXml(new MemoryStream(p));</from>
				<default               >return p == null? SqlXml.Null: new SqlXml(p);</default>
			</group>
			<group name="SqlTypes">
				<from type="SqlString">return p.IsNull? SqlXml.Null: new SqlXml(new XmlTextReader(new StringReader(p.Value)));</from>
				<from type="SqlChars" >return p.IsNull? SqlXml.Null: new SqlXml(new XmlTextReader(new StringReader(p.ToSqlString().Value)));</from>
				<from type="SqlBinary">return p.IsNull? SqlXml.Null: new SqlXml(new MemoryStream(p.Value));</from>
				<from type="SqlBytes" >return p.IsNull? SqlXml.Null: new SqlXml(p.Stream);</from>
			</group>
			<default nullvalue="SqlXml.Null"/>
		</converter>
	</region>
	<region name="Other Types">
		<converter type="Type">
			<group name="Scalar Types.">
				<from type="String"   >return p == null?       null: Type.GetType(p);                  </from>
				<from type="Char[]"   >return p == null?       null: Type.GetType(new string(p));      </from>
				<from type="Byte[]"   >return p == null?       null: Type.GetTypeFromCLSID(ToGuid(p)); </from>
				<from type="Guid"     >return p == Guid.Empty? null: Type.GetTypeFromCLSID(p);         </from>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="Guid"     >return p.HasValue? Type.GetTypeFromCLSID(p.Value): null;</from>
			</group>
			<group name="SqlTypes">
				<from type="SqlString">return p.IsNull       ? null: Type.GetType(p.Value);            </from>
				<from type="SqlChars" >return p.IsNull       ? null: Type.GetType(new string(p.Value));</from>
				<from type="SqlGuid"  >return p.IsNull       ? null: Type.GetTypeFromCLSID(p.Value);   </from>
			</group>
			<default nullvalue="null"/>
		</converter>
		<converter type="Stream">
			<group name="Scalar Types.">
				<from type="Guid"     >return p == Guid.Empty? Stream.Null: new MemoryStream(p.ToByteArray());</from>
				<from type="Byte[]"   >return p == null? Stream.Null: new MemoryStream(p);</from>
			</group>
			<group name="Nullable Types." nullable="true">
				<from type="Guid"     >return p.HasValue? new MemoryStream(p.Value.ToByteArray()): Stream.Null;</from>
			</group>
			<group name="SqlTypes">
				<from type="SqlBytes" >return p.IsNull? Stream.Null: p.Stream;                 </from>
				<from type="SqlBinary">return p.IsNull? Stream.Null: new MemoryStream(p.Value);</from>
				<from type="SqlGuid"  >return p.IsNull? Stream.Null: new MemoryStream(p.Value.ToByteArray());</from>
			</group>
			<default nullvalue="Stream.Null"/>
		</converter>
		<converter type="Byte[]" name="ByteArray">
			<group name="Scalar Types.">
				<from type="String" >return p == null? null: System.Text.Encoding.UTF8.GetBytes(p);</from>
				<from type="Byte"   >return new byte[]{p};</from>
				<from type="SByte"  >return new byte[]{checked((Byte)p)};</from>
				<from type="Decimal">
			int[]  bits  = Decimal.GetBits(p);
			Byte[] bytes = new Byte[Buffer.ByteLength(bits)];

			Buffer.BlockCopy(bits, 0, bytes, 0, bytes.Length);
			return bytes;</from>
				<include template="Numeric Types"/>
				<from type="Char" />
				<from type="DateTime"   >return ToByteArray(p.ToBinary());</from>
				<from type="DateTimeOffset"   >return ToByteArray(p.LocalDateTime.ToBinary());</from>
				<from type="TimeSpan"   >return ToByteArray(p.Ticks);</from>
				<from type="Stream" >
			if (p == null)         return null;
			if (p is MemoryStream) return ((MemoryStream)p).ToArray();

			long   position = p.Seek(0, SeekOrigin.Begin);
			Byte[] bytes = new Byte[p.Length];
			p.Read(bytes, 0, bytes.Length);
			p.Position = position;

			return bytes;</from>
				<from type="Char[]" >
			Byte[] bytes = new Byte[Buffer.ByteLength(p)];

			Buffer.BlockCopy(p, 0, bytes, 0, bytes.Length);
			return bytes;</from>
				<from type="Guid"   >return p == Guid.Empty? null: p.ToByteArray();</from>
				<default              >return BitConverter.GetBytes(p);</default>
			</group>
			<group name="Nullable Types." nullable="true">
				<include template="Numeric Types"/>
				<from type="Char" />
				<from type="DateTime" />
				<from type="DateTimeOffset" />
				<from type="TimeSpan" />
				<from type="Guid"     />
				<default              >return p.HasValue? ToByteArray(p.Value): null;</default>
			</group>
			<group name="SqlTypes">
				<from type="SqlBinary">return p.IsNull? null: p.Value;</from>
				<from type="SqlBytes" >return p.IsNull? null: p.Value;</from>
				<from type="SqlGuid"  >return p.IsNull? null: p.ToByteArray();</from>
				<include template="SqlTypes"/>
				<default              >return p.IsNull? null: ToByteArray(p.Value);</default>
			</group>
			<default nullvalue="null"/>
		</converter>
		<converter type="Char[]" name="CharArray">
			<group name="Scalar Types.">
				<from type="String" >return p == null? null: p.ToCharArray();</from>
			</group>
			<group name="SqlTypes">
				<from type="SqlString" >return p.IsNull? null: p.Value.ToCharArray();</from>
				<from type="SqlChars"  >return p.IsNull? null: p.Value;</from>
			</group>
			<from type="Byte[]" >
				if (p == null) return null;

				Char[] chars = new Char[p.Length / sizeof(Char)];

				Buffer.BlockCopy(p, 0, chars, 0, p.Length);
				return chars;
			</from>
			<default nullvalue="null" nothrow="true">
			return ToString(p).ToCharArray();</default>
		</converter>
		<converter type="XmlReader">
			<group name="Scalar Types.">
				<from type="String"    >return p == null? null: new XmlTextReader(new StringReader(p));</from>
			</group>
			<group name="SqlTypes">
				<from type="SqlXml"   >return p.IsNull? null: p.CreateReader();</from>
				<from type="SqlString">return p.IsNull? null: new XmlTextReader(new StringReader(p.Value));</from>
				<from type="SqlChars" >return p.IsNull? null: new XmlTextReader(new StringReader(p.ToSqlString().Value));</from>
				<from type="SqlBinary">return p.IsNull? null: new XmlTextReader(new MemoryStream(p.Value));</from>
				<default              >return p.IsNull? null: new XmlTextReader(p.Value);</default>
			</group>
			<group name="Other Types.">
				<from type="Stream"   />
				<from type="TextReader" nick="TR"/>
				<from type="XmlDocument">return p == null? null: new XmlTextReader(new StringReader(p.InnerXml));</from>
				<br/>
				<from type="Char[]"     >return p == null? null: new XmlTextReader(new StringReader(new string(p)));</from>
				<from type="Byte[]"     >return p == null? null: new XmlTextReader(new MemoryStream(p));</from>
				<default                >return p == null? null: new XmlTextReader(p);</default>
			</group>
			<default nullvalue="null"/>
		</converter>
		<converter type="XmlDocument">
			<group name="Scalar Types.">
				<from type="String"    >
			if (string.IsNullOrEmpty(p)) return null;

			XmlDocument doc = new XmlDocument();
			doc.LoadXml(p);
			return doc;</from>
			</group>
			<group name="SqlTypes">
				<from type="SqlString"/>
				<from type="SqlXml"   />
				<from type="SqlChars" >return p.IsNull? null: ToXmlDocument(p.ToSqlString().Value);</from>
				<from type="SqlBinary">return p.IsNull? null: ToXmlDocument(new MemoryStream(p.Value));</from>
				<default              >return p.IsNull? null: ToXmlDocument(p.Value);</default>
			</group>
			<group name="Other Types.">
				<from type="Stream"   />
				<from type="TextReader" nick="TR"/>
				<from type="XmlReader"/>
				<br/>
				<from type="Char[]"     >return p == null || p.Length == 0? null: ToXmlDocument(new string(p));</from>
				<from type="Byte[]"     >return p == null || p.Length == 0? null: ToXmlDocument(new MemoryStream(p));</from>
				<default                >
					if (p == null) return null;

					XmlDocument doc = new XmlDocument();
					doc.Load(p);
					return doc;
				</default>
			</group>
			<default nullvalue="null"/>
		</converter>
	</region>
</code>
